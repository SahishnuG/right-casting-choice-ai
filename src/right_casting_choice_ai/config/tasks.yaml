extract_characters_task:
  description: >
    Given the user plot string "{plot}", extract ALL distinct characters mentioned in the plot
    (no upper limit) and their characteristics (role, name_hint, age_range, traits, gender).
    Aim for at least 2 characters when possible; if the plot truly contains fewer than 2, return
    all available characters. **Return JSON array only.**
    DO NOT include any explanatory text. The assistant must return a compact JSON array exactly.
    Optional hints from the app may be provided:
      - expected_character_count: ensure you return at least this many characters.
      - expected_character_names: ensure all listed names/roles are included (use as name_hint/role as appropriate).
  expected_output: >
    A JSON array (2+ items when possible; if the plot has fewer, return what's available) like:
    [
      {"role":"Lead Male","name_hint":"Arjun","age_range":"25-35","traits":["brave","reckless"], "gender":"male"},
      {"role":"Lead Female","name_hint":"Meera","age_range":"20-30","traits":["witty","fierce"], "gender":"female"}
    ]
  agent: character_extractor

similar_movies_task:
  description: >
    Using the plot "{plot}", industry={industry}, and n_similar={n_similar}, run Serper to find n_similar
    movie titles and fetch OMDb metadata for each. Enforce thematic relevance:
      - Extract 6-10 key plot keywords from {plot} (entities, subgenres, motifs).
      - Filter candidate movies by genre/subgenre and these keywords; exclude off-theme results.
      - Compute a numeric match_score (0-100) per movie based on keyword overlap, genre match, and synopsis alignment.
    Use USD→INR={usd_to_inr} when converting non-INR amounts for Bollywood preference.
    Return a single shared list of movie dicts with normalized fields.
  expected_output: >
    A JSON array of dicts. Each dict includes: Title, Year, Actors, Poster, BoxOfficeINR, BudgetINR, imdbRating, imdbID, match_score (int), _raw
  agent: similar_movies_and_omdb

rank_candidates_task:
  description: >
    Aggregate actors from the OMDb results and compute scores given user_budget_inr or user_budget_usd
    depending on industry={industry}. The user's total budget will be provided as either user_budget_inr (Bollywood) or user_budget_usd (Hollywood); keep this overall budget in mind when choosing actors, preferring combinations that keep the sum of selected fees across roles within budget. Do NOT select the same actor for multiple roles. For each character profile returned by extract_characters_task:
      - First, construct a comprehensive candidate pool by using ALL actor names appearing in the shared similar-movies array (from OMDb `Actors` field across all returned movies). Normalize names and deduplicate. This ensures supporting roles have adequate candidates even if prior tasks missed them.
      - Ensure the returned candidate list respects the character's gender and age_range (drop mismatches).
      - If optional hints are provided from the app (expected_character_count / expected_character_names),
        ensure all those characters are included in the final JSON array.
      - If a character has no candidates after filtering, run Serper to find actors who can play that character.
      - For each actor candidate, query the web (via Serper) to estimate an actor fee per film.
        IMPORTANT: Use remuneration/salary/"per film fee" sources only. NEVER use "net worth" sources
        (e.g., pages with words like "net worth", "wealth", or sites such as celebritynetworth etc.).
        Prefer reputable outlets (trade publications, interviews, news articles). If only ranges are found,
        compute the midpoint.
      - Normalize the extracted fee to a single integer field "implied_actor_fee_estimate" (raw INR).
      - If Serper returns a range, use the midpoint; if USD, convert using USD→INR.
      - Add a "fee_source" string (short provenance — URL or snippet). Ensure the source clearly references
        a per-project fee/remuneration, not net worth; otherwise search again.
      - Compute a "score" combining imdb rating, average box office, and budget-fit (lower fee relative to user_budget raises budget-fit). Penalize candidates whose fees push the cumulative total across roles over the provided overall budget (user_budget_inr/user_budget_usd). Enforce global uniqueness: if an actor appears as top for more than one role, keep them only for the role with the best combined score + budget fit, and demote/remove from other roles.
      - Sort candidates within each role by descending score (tie-break by lower implied_actor_fee_estimate). The first item must be the top candidate, already considering total budget and uniqueness constraints.
    Return a JSON array (one object per character) with the following structure (minimum fields required; no commentary). Do NOT include a per-role "movies" array — the app provides a single shared movies list from similar_movies_task:
    [
      {
        "role": "Lead Male",
        "name_hint": "Arjun",
        "age_range": "25-35",
        "gender": "male",
        "candidates": [
          {
            "name": "Ajay Devgn",
            "imdb_rating": 7.6,
            "average_box_office_inr": 83861955,
            "implied_actor_fee_estimate": 350000000,
            "fee_source": "https://example.com/snippet-or-url",
            "score": 7.3
          },
          ...
        ],
        "recommended_pool": [ top 6 candidate objects ],
      },
      ...
    ]
  expected_output: >
    A JSON array (at least 2 items) as shown above. Return valid JSON only (no extra commentary).
  agent: budget_ranker
